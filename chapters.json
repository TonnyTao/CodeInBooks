[{"title":"TheBasics","details":["Declaring Constants and Variables","Type Annotations","Naming Constants and Variables","Printing Constants and Variables","Comments","Semicolons","Integer Bounds","Type Safety and Type Inference","Numeric Literals","Integer Conversion","Integer and Floating-Point Conversion","Type Aliases","Booleans","Tuples","Optionals","nil","If Statements and Forced Unwrapping","Optional Binding","Implicitly Unwrapped Optionals","Error Handling","Debugging with Assertions"]},{"title":"BasicOperators","details":["Assignment Operator","Arithmetic Operators","Remainder Operator","Unary Minus Operator","Unary Plus Operator","Compound Assignment Operators","Comparison Operators","Ternary Conditional Operator","Nil-Coalescing Operator","Closed Range Operator","Half-Open Range Operator","Logical NOT Operator","Logical AND Operator","Logical OR Operator","Combining Logical Operators","Explicit Parentheses"]},{"title":"StringsAndCharacters","details":["String Literals","Initializing an Empty String","String Mutability","Working with Characters","Concatenating Strings and Characters","String Interpolation","Special Characters in String Literals","Extended Grapheme Clusters","Counting Characters","String Indices","Inserting and Removing","String and Character Equality","Prefix and Suffix Equality","Unicode Representations of Strings","UTF-8 Representation","UTF-16 Representation","Unicode Scalar Representation"]},{"title":"CollectionTypes","details":["Creating an Empty Array","Creating an Array with a Default Value","Creating an Array by Adding Two Arrays Together","Creating an Array with an Array Literal","Accessing and Modifying an Array","Iterating Over an Array","Creating and Initializing an Empty Set","Creating a Set with an Array Literal","Accessing and Modifying a Set","Iterating Over a Set","Fundamental Set Operations","Set Membership and Equality","Creating an Empty Dictionary","Creating a Dictionary with a Dictionary Literal","Accessing and Modifying a Dictionary","Iterating Over a Dictionary"]},{"title":"ControlFlow","details":["For-In Loops","While","Repeat-While","If","Switch","No Implicit Fallthrough","Interval Matching","Tuples","Value Bindings","Where","Compound Cases","Continue","Break in a Switch Statement","Fallthrough","Labeled Statements","Early Exit","Checking API Availability"]},{"title":"Functions","details":["Defining and Calling Functions","Functions Without Parameters","Functions With Multiple Parameters","Functions Without Return Values","Functions with Multiple Return Values","Optional Tuple Return Types","Function Argument Labels and Parameter Names","Specifying Argument Labels","Omitting Argument Labels","Default Parameter Values","Variadic Parameters","In-Out Parameters","Function Types","Using Function Types","Function Types as Parameter Types","Function Types as Return Types","Nested Functions"]},{"title":"Closures","details":["The Sorted Method","Closure Expression Syntax","Inferring Type From Context","Implicit Returns from Single-Expression Closures","Shorthand Argument Names","Operator Methods","Trailing Closures","Capturing Values","Closures Are Reference Types","Escaping Closures","Autoclosures"]},{"title":"Enumerations","details":["Enumeration Syntax","Matching Enumeration Values with a Switch Statement","Associated Values","Raw Values","Implicitly Assigned Raw Values","Initializing from a Raw Value","Recursive Enumerations"]},{"title":"ClassesAndStructures","details":["Definition Syntax","Class and Structure Instances","Accessing Properties","Memberwise Initializers for Structure Types","Structures and Enumerations Are Value Types","Classes Are Reference Types","Identity Operators"]},{"title":"Properties","details":["Stored Properties","Stored Properties of Constant Structure Instances","Lazy Stored Properties","Computed Properties","Shorthand Setter Declaration","Read-Only Computed Properties","Property Observers","Type Property Syntax","Querying and Setting Type Properties"]},{"title":"Methods","details":["Instance Methods","The self Property","Modifying Value Types from Within Instance Methods","Assigning to self Within a Mutating Method","Type Methods"]},{"title":"Subscripts","details":["Subscript Syntax","Subscript Usage","Subscript Options"]},{"title":"Inheritance","details":["Defining a Base Class","Subclassing","Overriding Methods","Overriding Property Getters and Setters","Overriding Property Observers"]},{"title":"Initialization","details":["Initializers","Default Property Values","Initialization Parameters","Parameter Names and Argument Labels","Initializer Parameters Without Argument Labels","Optional Property Types","Assigning Constant Properties During Initialization","Default Initializers","Memberwise Initializers for Structure Types","Initializer Delegation for Value Types","Initializer Inheritance and Overriding","Designated and Convenience Initializers in Action","Failable Initializers","Failable Initializers for Enumerations","Failable Initializers for Enumerations with Raw Values","Propagation of Initialization Failure","Overriding a Failable Initializer","Required Initializers","Setting a Default Property Value with a Closure or Function"]},{"title":"Deinitialization","details":["How Deinitialization Works","Deinitializers in Action"]},{"title":"AutomaticReferenceCounting","details":["ARC in Action","Strong Reference Cycles Between Class Instances","Weak References","Unowned References","Unowned References and Implicitly Unwrapped Optional Properties","Strong Reference Cycles for Closures","Defining a Capture List","Weak and Unowned References"]},{"title":"OptionalChaining","details":["Optional Chaining as an Alternative to Forced Unwrapping","Defining Model Classes for Optional Chaining","Accessing Properties Through Optional Chaining","Calling Methods Through Optional Chaining","Accessing Subscripts Through Optional Chaining","Accessing Subscripts of Optional Type","Linking Multiple Levels of Chaining","Chaining on Methods with Optional Return Values"]},{"title":"ErrorHandling","details":["Representing and Throwing Errors","Propagating Errors Using Throwing Functions","Handling Errors Using Do-Catch","Converting Errors to Optional Values","Disabling Error Propagation","Specifying Cleanup Actions"]},{"title":"TypeCasting","details":["Defining a Class Hierarchy for Type Casting","Checking Type","Downcasting","Type Casting for Any and AnyObject"]},{"title":"NestedTypes","details":["Nested Types in Action","Referring to Nested Types"]},{"title":"Extensions","details":["Extension Syntax","Computed Properties","Initializers","Methods","Mutating Instance Methods","Subscripts","Nested Types"]},{"title":"Protocols","details":["Protocol Syntax","Property Requirements","Method Requirements","Mutating Method Requirements","Initializer Requirements","Class Implementations of Protocol Initializer Requirements","Protocols as Types","Delegation","Adding Protocol Conformance with an Extension","Declaring Protocol Adoption with an Extension","Collections of Protocol Types","Protocol Inheritance","Class-Only Protocols","Protocol Composition","Checking for Protocol Conformance","Optional Protocol Requirements","Protocol Extensions","Providing Default Implementations","Adding Constraints to Protocol Extensions"]},{"title":"Generics","details":["The Problem That Generics Solve","Generic Functions","Generic Types","Extending a Generic Type","Type Constraint Syntax","Type Constraints in Action","Associated Types in Action","Extending an Existing Type to Specify an Associated Type","Generic Where Clauses"]},{"title":"AccessControl","details":["Access Control Syntax","Custom Types","Function Types","Enumeration Types","Subclassing","Constants, Variables, Properties, and Subscripts","Getters and Setters"]},{"title":"AdvancedOperators","details":["Bitwise NOT Operator","Bitwise AND Operator","Bitwise OR Operator","Bitwise XOR Operator","Shifting Behavior for Unsigned Integers","Overflow Operators","Value Overflow","Precedence and Associativity","Operator Methods","Prefix and Postfix Operators","Compound Assignment Operators","Equivalence Operators","Custom Operators","Precedence for Custom Infix Operators"]}]