<pre><code class="code _highlighted" data-lang="text/x-kotlin">class Int {
    //...
    operator fun rangeTo(other: Long): LongRange = LongRange(this, other)
    //...
    operator fun rangeTo(other: Int): IntRange = IntRange(this, other)
    //...
}
</code></pre>
<pre><code class="code _highlighted" data-lang="text/x-kotlin">    public operator fun &lt;T: Comparable&lt;T&gt;&gt; T.rangeTo(that: T): ClosedRange&lt;T&gt;
</code></pre>
<pre><code class="code _highlighted" data-lang="text/x-kotlin">fun Long.downTo(other: Int): LongProgression {
    return LongProgression.fromClosedRange(this, other, -1.0)
}

fun Byte.downTo(other: Int): IntProgression {
    return IntProgression.fromClosedRange(this, other, -1)
}
</code></pre>
<pre><code class="code _highlighted" data-lang="text/x-kotlin">fun IntProgression.reversed(): IntProgression {
    return IntProgression.fromClosedRange(last, first, -increment)
}
</code></pre>
<pre><code class="code _highlighted" data-lang="text/x-kotlin">fun IntProgression.step(step: Int): IntProgression {
    if (step &lt;= 0) throw IllegalArgumentException(&quot;Step must be positive, was: $step&quot;)
    return IntProgression.fromClosedRange(first, last, if (increment &gt; 0) step else -step)
}

fun CharProgression.step(step: Int): CharProgression {
    if (step &lt;= 0) throw IllegalArgumentException(&quot;Step must be positive, was: $step&quot;)
    return CharProgression.fromClosedRange(first, last, step)
}
</code></pre>
<pre><code class="code _highlighted" data-lang="text/x-kotlin">    (1..12 step 2).last == 11  // progression with values [1, 3, 5, 7, 9, 11]
    (1..12 step 3).last == 10  // progression with values [1, 4, 7, 10]
    (1..12 step 4).last == 9   // progression with values [1, 5, 9]
</code></pre>
