<pre><code class="code _highlighted" data-lang="text/x-kotlin">val a: Int = 10000
print(a === a) // Prints &apos;true&apos;
val boxedA: Int? = a
val anotherBoxedA: Int? = a
print(boxedA === anotherBoxedA) // !!!Prints &apos;false&apos;!!!
</code></pre>
<pre><code class="code _highlighted" data-lang="text/x-kotlin">val a: Int = 10000
print(a == a) // Prints &apos;true&apos;
val boxedA: Int? = a
val anotherBoxedA: Int? = a
print(boxedA == anotherBoxedA) // Prints &apos;true&apos;
</code></pre>
<pre><code class="code _highlighted" data-lang="text/x-kotlin">// Hypothetical code, does not actually compile:
val a: Int? = 1 // A boxed Int (java.lang.Integer)
val b: Long? = a // implicit conversion yields a boxed Long (java.lang.Long)
print(a == b) // Surprise! This prints &quot;false&quot; as Long&apos;s equals() check for other part to be Long as well
</code></pre>
<pre><code class="code _highlighted" data-lang="text/x-kotlin">val b: Byte = 1 // OK, literals are checked statically
val i: Int = b // ERROR
</code></pre>
<pre><code class="code _highlighted" data-lang="text/x-kotlin">val i: Int = b.toInt() // OK: explicitly widened
</code></pre>
<pre><code class="code _highlighted" data-lang="text/x-kotlin">val l = 1L + 3 // Long + Int =&gt; Long
</code></pre>
<pre><code class="code _highlighted" data-lang="text/x-kotlin">val x = (1 shl 2) and 0x000FF000
</code></pre>
