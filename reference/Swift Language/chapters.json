[{"title":"The Basics","details":["Declaring Constants and Variables","Type Annotations","Naming Constants and Variables","Printing Constants and Variables","Comments","Semicolons","Integer Bounds","Type Safety and Type Inference","Numeric Literals","Integer Conversion","Integer and Floating-Point Conversion","Type Aliases","Booleans","Tuples","Optionals","nil","If Statements and Forced Unwrapping","Optional Binding","Implicitly Unwrapped Optionals","Error Handling","Debugging with Assertions","Enforcing Preconditions"]},{"title":"Basic Operators","details":["Assignment Operator","Arithmetic Operators","Remainder Operator","Unary Minus Operator","Unary Plus Operator","Compound Assignment Operators","Comparison Operators","Ternary Conditional Operator","Nil-Coalescing Operator","Closed Range Operator","Half-Open Range Operator","One-Sided Ranges","Logical NOT Operator","Logical AND Operator","Logical OR Operator","Combining Logical Operators","Explicit Parentheses"]},{"title":"Strings and Characters","details":["String Literals","Multiline String Literals","Special Characters in String Literals","Initializing an Empty String","String Mutability","Working with Characters","Concatenating Strings and Characters","String Interpolation","Extended Grapheme Clusters","Counting Characters","String Indices","Inserting and Removing","Substrings","String and Character Equality","Prefix and Suffix Equality","Unicode Representations of Strings","UTF-8 Representation","UTF-16 Representation","Unicode Scalar Representation"]},{"title":"Collection Types","details":["Creating an Empty Array","Creating an Array with a Default Value","Creating an Array by Adding Two Arrays Together","Creating an Array with an Array Literal","Accessing and Modifying an Array","Iterating Over an Array","Creating and Initializing an Empty Set","Creating a Set with an Array Literal","Accessing and Modifying a Set","Iterating Over a Set","Fundamental Set Operations","Set Membership and Equality","Creating an Empty Dictionary","Creating a Dictionary with a Dictionary Literal","Accessing and Modifying a Dictionary","Iterating Over a Dictionary"]},{"title":"Control Flow","details":["For-In Loops","While","Repeat-While","If","Switch","No Implicit Fallthrough","Interval Matching","Tuples","Value Bindings","Where","Compound Cases","Continue","Break in a Switch Statement","Fallthrough","Labeled Statements","Early Exit","Checking API Availability"]},{"title":"Functions","details":["Defining and Calling Functions","Functions Without Parameters","Functions With Multiple Parameters","Functions Without Return Values","Functions with Multiple Return Values","Optional Tuple Return Types","Function Argument Labels and Parameter Names","Specifying Argument Labels","Omitting Argument Labels","Default Parameter Values","Variadic Parameters","In-Out Parameters","Function Types","Using Function Types","Function Types as Parameter Types","Function Types as Return Types","Nested Functions"]},{"title":"Closures","details":["The Sorted Method","Closure Expression Syntax","Inferring Type From Context","Implicit Returns from Single-Expression Closures","Shorthand Argument Names","Operator Methods","Trailing Closures","Capturing Values","Closures Are Reference Types","Escaping Closures","Autoclosures"]},{"title":"Enumerations","details":["Enumeration Syntax","Matching Enumeration Values with a Switch Statement","Associated Values","Raw Values","Implicitly Assigned Raw Values","Initializing from a Raw Value","Recursive Enumerations"]},{"title":"Classes and Structures","details":["Definition Syntax","Class and Structure Instances","Accessing Properties","Memberwise Initializers for Structure Types","Structures and Enumerations Are Value Types","Classes Are Reference Types","Identity Operators"]},{"title":"Properties","details":["Stored Properties","Stored Properties of Constant Structure Instances","Lazy Stored Properties","Computed Properties","Shorthand Setter Declaration","Read-Only Computed Properties","Property Observers","Type Property Syntax","Querying and Setting Type Properties"]},{"title":"Methods","details":["Instance Methods","The self Property","Modifying Value Types from Within Instance Methods","Assigning to self Within a Mutating Method","Type Methods"]},{"title":"Subscripts","details":["Subscript Syntax","Subscript Usage","Subscript Options"]},{"title":"Inheritance","details":["Defining a Base Class","Subclassing","Overriding Methods","Overriding Property Getters and Setters","Overriding Property Observers"]},{"title":"Initialization","details":["Initializers","Default Property Values","Initialization Parameters","Parameter Names and Argument Labels","Initializer Parameters Without Argument Labels","Optional Property Types","Assigning Constant Properties During Initialization","Default Initializers","Memberwise Initializers for Structure Types","Initializer Delegation for Value Types","Initializer Inheritance and Overriding","Designated and Convenience Initializers in Action","Failable Initializers","Failable Initializers for Enumerations","Failable Initializers for Enumerations with Raw Values","Propagation of Initialization Failure","Overriding a Failable Initializer","Required Initializers","Setting a Default Property Value with a Closure or Function"]},{"title":"Deinitialization","details":["How Deinitialization Works","Deinitializers in Action"]},{"title":"Optional Chaining","details":["Optional Chaining as an Alternative to Forced Unwrapping","Defining Model Classes for Optional Chaining","Accessing Properties Through Optional Chaining","Calling Methods Through Optional Chaining","Accessing Subscripts Through Optional Chaining","Accessing Subscripts of Optional Type","Linking Multiple Levels of Chaining","Chaining on Methods with Optional Return Values"]},{"title":"Error Handling","details":["Representing and Throwing Errors","Propagating Errors Using Throwing Functions","Handling Errors Using Do-Catch","Converting Errors to Optional Values","Disabling Error Propagation","Specifying Cleanup Actions"]},{"title":"Type Casting","details":["Defining a Class Hierarchy for Type Casting","Checking Type","Downcasting","Type Casting for Any and AnyObject"]},{"title":"Nested Types","details":["Nested Types in Action","Referring to Nested Types"]},{"title":"Extensions","details":["Extension Syntax","Computed Properties","Initializers","Methods","Mutating Instance Methods","Subscripts","Nested Types"]},{"title":"Protocols","details":["Protocol Syntax","Property Requirements","Method Requirements","Mutating Method Requirements","Initializer Requirements","Class Implementations of Protocol Initializer Requirements","Protocols as Types","Delegation","Adding Protocol Conformance with an Extension","Declaring Protocol Adoption with an Extension","Collections of Protocol Types","Protocol Inheritance","Class-Only Protocols","Protocol Composition","Checking for Protocol Conformance","Optional Protocol Requirements","Protocol Extensions","Providing Default Implementations","Adding Constraints to Protocol Extensions"]},{"title":"Generics","details":["The Problem That Generics Solve","Generic Functions","Generic Types","Extending a Generic Type","Type Constraint Syntax","Type Constraints in Action","Associated Types in Action","Extending an Existing Type to Specify an Associated Type","Using Type Annotations to Constrain an Associated Type","Generic Where Clauses","Extensions with a Generic Where Clause","Associated Types with a Generic Where Clause","Generic Subscripts"]},{"title":"Automatic Reference Counting","details":["ARC in Action","Strong Reference Cycles Between Class Instances","Weak References","Unowned References","Unowned References and Implicitly Unwrapped Optional Properties","Strong Reference Cycles for Closures","Defining a Capture List","Weak and Unowned References"]},{"title":"Memory Safety","details":["Understanding Conflicting Access to Memory","Characteristics of Memory Access","Conflicting Access to In-Out Parameters","Conflicting Access to self in Methods","Conflicting Access to Properties"]},{"title":"Access Control","details":["Access Control Syntax","Custom Types","Function Types","Enumeration Types","Subclassing","Constants, Variables, Properties, and Subscripts","Getters and Setters","Private Members in Extensions"]},{"title":"Advanced Operators","details":["Bitwise NOT Operator","Bitwise AND Operator","Bitwise OR Operator","Bitwise XOR Operator","Shifting Behavior for Unsigned Integers","Overflow Operators","Value Overflow","Precedence and Associativity","Operator Methods","Prefix and Postfix Operators","Compound Assignment Operators","Equivalence Operators","Custom Operators","Precedence for Custom Infix Operators"]}]