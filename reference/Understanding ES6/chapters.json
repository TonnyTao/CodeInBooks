[{"title":"Introduction","details":["Conventions Used"]},{"title":"Block Bindings","details":["Help and Support","Let Declarations","No Redeclaration","Constant Declarations","The Temporal Dead Zone","Functions in Loops","Let Declarations in Loops","Constant Declarations in Loops"]},{"title":"Strings and Regular Expressions","details":["UTF-16 Code Points","The codePointAt() Method","The String.fromCodePoint() Method","The normalize() Method","The Regular Expression u Flag","Methods for Identifying Substrings","The repeat() Method","The Regular Expression y Flag","Duplicating Regular Expressions","The flags Property","Basic Syntax","Multiline Strings","Making Substitutions","Tagged Templates"]},{"title":"Functions","details":["Simulating Default Parameter Values in ECMAScript 5","Default Parameter Values in ECMAScript 6","How Default Parameter Values Affect the arguments Object","Default Parameter Expressions","Default Parameter Value Temporal Dead Zone","Unnamed Parameters in ECMAScript 5","Rest Parameters","Choosing Appropriate Names","Special Cases of the name Property","Determining How a Function was Called in ECMAScript 5","The new.target MetaProperty","Deciding When to Use Block-Level Functions","Block-Level Functions in Nonstrict Mode","Arrow Function Syntax","Creating Immediately-Invoked Function Expressions","No this Binding","Arrow Functions and Arrays","No arguments Binding","Identifying Arrow Functions",{"name":"What’s Different?","file":"What’s Different"},"How to Harness Tail Call Optimization"]},{"title":"Expanded Object Functionality","details":["Property Initializer Shorthand","Concise Methods","Computed Property Names","The Object.is() Method","The Object.assign() Method","Working with Accessor Properties","Changing an Object’s Prototype","Easy Prototype Access with Super References"]},{"title":"Destructuring for Easier Data Access","details":["Easy Prototype Access with Super References","Destructured Parameters are Required","Default Values for Destructured Parameters"]},{"title":"Symbols and Symbol Properties","details":["Default Values for Destructured Parameters","Identifying Symbols","The Symbol.hasInstance Property","The Symbol.isConcatSpreadable Symbol","The Symbol.match, Symbol.replace, Symbol.search, and Symbol.split Symbols","The Symbol.toPrimitive Symbol","The Symbol.toStringTag Symbol","The Symbol.unscopables Symbol"]},{"title":"Sets and Maps","details":["The Symbol.unscopables Symbol","Creating Sets and Adding Items","Removing Values","The forEach() Method for Sets","Converting a Set to an Array","Weak Sets","Map Methods","Map Initialization","The forEach Method on Maps","Weak Maps"]},{"title":"Iterators and Generators","details":["Weak Maps","Generator Function Expressions","Generator Object Methods","Accessing the Default Iterator","Creating Iterables","Collection Iterators","Destructuring and for-of Loops","String Iterators","NodeList Iterators","Passing Arguments to Iterators","Throwing Errors in Iterators","Generator Return Statements","Delegating Generators","A Simple Task Runner","Task Running With Data","Asynchronous Task Runner"]},{"title":"Introducing JavaScript Classes","details":["Asynchronous Task Runner","A Basic Class Declaration","Why to Use the Class Syntax","Constant Class Names","A Basic Class Expression","Named Class Expressions","Shadowing Class Methods","Inherited Static Members","Derived Classes from Expressions","Inheriting from Built-ins","The Symbol.species Property"]},{"title":"Improved Array Capabilities","details":["The Array.of() Method","The Array.from() Method","The find() and findIndex() Methods","The fill() Method","The copyWithin() Method","Array Buffers","Manipulating Array Buffers with Views","Element Size","Common Methods","The Same Iterators","of() and from() Methods","Behavioral Differences","Additional Methods"]},{"title":"Promises and Asynchronous Programming","details":["The Event Model","The Callback Pattern","The Promise Lifecycle","Creating Unsettled Promises","Creating Settled Promises","Executor Errors","Node.js Rejection Handling","Browser Rejection Handling","Catching Errors","Returning Values in Promise Chains","Returning Promises in Promise Chains","The Promise.all() Method","The Promise.race() Method","Asynchronous Task Running","Future Asynchronous Task Running"]},{"title":"Proxies and the Reflection API","details":["Asynchronous Task Running","How Prototype Proxy Traps Work",{"name":"Why Two Sets of Methods?","file":"Why Two Sets of Methods"},"Two Basic Examples","Duplicate Extensibility Methods","Blocking Object.defineProperty()","Descriptor Object Restrictions","Duplicate Descriptor Methods","Validating Function Parameters","Calling Constructors Without new","Overriding Abstract Base Class Constructors","Callable Class Constructors","Detecting Array Indices","Increasing length when Adding New Elements","Deleting Elements on Reducing length","Implementing the MyArray Class","Using the get Trap on a Prototype","Using the set Trap on a Prototype","Using the has Trap on a Prototype","Proxies as Prototypes on Classes"]},{"title":"Encapsulating Code With Modules","details":["Proxies as Prototypes on Classes","Importing a Single Binding","Importing Multiple Bindings","Importing All of a Module","Module Syntax Limitations","A Subtle Quirk of Imported Bindings","Exporting Default Values","Importing Default Values","Using Modules in Web Browsers","Browser Module Specifier Resolution"]},{"title":"Appendix A: Smaller Changes","details":["Identifying Integers","Safe Integers"]},{"title":"Appendix B: Understanding ECMAScript 7 (2016)","details":["Safe Integers","Order of Operations","Operand Restriction","How to Use Array.prototype.includes()","Value Comparison"]}]