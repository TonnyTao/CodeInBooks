[{"title":"Basic Syntax","details":["Defining packages","Defining functions","Defining local variables","Comments","Using string templates","Using conditional expressions","Using nullable values and checking for null","Using type checks and automatic casts","Using a for loop","Using a while loop","Using when expression","Using ranges","Using collections"]},{"title":"Idioms","details":[{"name":"Creating DTOs (POJOs/POCOs)","file":"Creating DTOs (POJOsPOCOs)"},"Default values for function parameters","Filtering a list","String Interpolation","Instance Checks",{"name":"Traversing a map/list of pairs","file":"Traversing a maplist of pairs"},"Using ranges","Read-only list","Read-only map","Accessing a map","Lazy property","Extension Functions","Creating a singleton","If not null shorthand","If not null and else shorthand","Executing a statement if null","Execute if not null","Return on when statement",{"name":"'try/catch' expression","file":"'trycatch' expression"},"'if' expression","Builder-style usage of methods that return Unit","Single-expression functions","Calling multiple methods on an object instance ('with')","Java 7's try with resources","Convenient form for a generic function that requires the generic type information","Consuming a nullable Boolean"]},{"title":"Coding Conventions","details":["Colon","Lambdas","Unit"]},{"title":"Basic Types","details":["Representation","Explicit Conversions","Operations","Characters","Arrays","Strings","String Literals","String Templates"]},{"title":"Packages","details":["Packages","Imports"]},{"title":"Control Flow","details":["If Expression","When Expression","For Loops","While Loops"]},{"title":"Returns and Jumps","details":["Break and Continue Labels","Return at Labels"]},{"title":"Classes and Inheritance","details":["Classes","Constructors","Secondary Constructors","Creating instances of classes","Inheritance","Overriding Methods","Overriding Properties","Overriding Rules","Abstract Classes","Sealed Classes"]},{"title":"Properties and Fields","details":["Declaring Properties","Getters and Setters","Backing Fields","Backing Properties","Compile-Time Constants","Late-Initialized Properties"]},{"title":"Interfaces","details":["Interfaces","Implementing Interfaces","Properties in Interfaces","Resolving overriding conflicts"]},{"title":"Visibility Modifiers","details":["Packages","Classes and Interfaces","Constructors"]},{"title":"Extensions","details":["Extension Functions","Extensions are resolved statically","Nullable Receiver","Extension Properties","Companion Object Extensions","Scope of Extensions","Declaring Extensions as Members","Motivation"]},{"title":"Data Classes","details":["Data Classes","Copying","Data Classes and Destructuring Declarations"]},{"title":"Generics","details":["Generics","Variance","Declaration-site variance",{"name":"Use-site variance: Type projections","file":"Use-site variance Type projections"},{"name":"Use-site variance: Type projections","file":"Use-site variance Type projections"},{"name":"Use-site variance: Type projections","file":"Use-site variance Type projections"},{"name":"Use-site variance: Type projections","file":"Use-site variance Type projections"},{"name":"Use-site variance: Type projections","file":"Use-site variance Type projections"},"Generic functions","Upper bounds"]},{"title":"Nested Classes","details":["Nested Classes","Inner classes","Anonymous inner classes"]},{"title":"Enum Classes","details":["Enum Classes","Initialization","Anonymous Classes","Working with Enum Constants"]},{"title":"Delegation","details":["Class Delegation"]},{"title":"Delegated Properties","details":["Delegated Properties","Lazy","Observable","Storing Properties in a Map"]},{"title":"Functions","details":["Function Declarations","Function Usage","Infix notation","Parameters","Default Arguments","Named Arguments","Unit-returning functions","Single-Expression functions","Variable number of arguments (Varargs)","Local Functions","Member Functions","Generic Functions","Tail recursive functions"]},{"title":"Inline Functions","details":["Inline Functions","noinline","Non-local returns","Reified type parameters"]},{"title":"Destructuring Declarations","details":["Destructuring Declarations",{"name":"Example: Returning Two Values from a Function","file":"Example Returning Two Values from a Function"},{"name":"Example: Destructuring Declarations and Maps","file":"Example Destructuring Declarations and Maps"},{"name":"Example: Destructuring Declarations and Maps","file":"Example Destructuring Declarations and Maps"}]},{"title":"Collections","details":["Collections"]},{"title":"Ranges","details":["Ranges","How it works","rangeTo()","downTo()","reversed()","step()"]},{"title":"Type Checks and Casts","details":[{"name":"is and !is Operators","file":"is and _is Operators"},"Smart Casts",{"name":"\"Unsafe\" cast operator","file":"Unsafe cast operator"},{"name":"\"Unsafe\" cast operator","file":"Unsafe cast operator"},{"name":"\"Safe\" (nullable) cast operator","file":"Safe (nullable) cast operator"}]},{"title":"This expressions","details":["Qualified this"]},{"title":"Equality","details":["Structural equality"]},{"title":"Null Safety","details":["Nullable types and Non-Null Types","Checking for null in conditions","Safe Calls","Elvis Operator",{"name":"The !! Operator","file":"The __ Operator"},"Safe Casts","Collections of Nullable Type"]},{"title":"Exceptions","details":["Exception Classes","Try is an expression","Checked Exceptions"]},{"title":"Annotations","details":["Annotation Declaration","Usage","Constructors","Lambdas","Annotation Use-site Targets","Java Annotations"]},{"title":"Reflection","details":["Class References","Function References",{"name":"Example: Function Composition","file":"Example Function Composition"},{"name":"Example: Function Composition","file":"Example Function Composition"},"Property References","Interoperability With Java Reflection","Constructor References"]},{"title":"Calling Java from Kotlin","details":["Calling Java code from Kotlin","Getters and Setters","Escaping for Java identifiers that are keywords in Kotlin","Null-Safety and Platform Types","Java generics in Kotlin","Java Arrays","Java Varargs","Checked Exceptions",{"name":"wait()/notify()","file":"wait()notify()"},"getClass()","clone()","finalize()","Accessing static members","SAM Conversions","Using JNI with Kotlin"]},{"title":"Calling Kotlin from Java","details":["Package-Level Functions","Instance Fields","Static Fields","Static Methods","KClass","Handling signature clashes with @JvmName","Overloads Generation","Checked Exceptions","Variant generics","Translation of type Nothing"]},{"title":"Dynamic Type","details":["Dynamic Type"]},{"title":"JavaScript Interoperability","details":["From Maven","From Gradle","@JsName Annotation"]},{"title":"JavaScript Reflection","details":["JavaScript Reflection"]},{"title":"Documenting Kotlin Code","details":["KDoc Syntax",{"name":"@param <name>","file":"@param name"},"Linking to Elements","Module and Package Documentation"]},{"title":"Using Maven","details":["Plugin and Versions","Dependencies","Compiling Kotlin only source code","Compiling Kotlin and Java sources","Jar file","Self-contained Jar file"]},{"title":"Using Ant","details":["Targeting JVM with Kotlin-only source","Targeting JVM with Kotlin-only source and multiple roots","Targeting JVM with Kotlin and Java source","Targeting JavaScript with single source folder","Targeting JavaScript with Prefix, PostFix and sourcemap options","Targeting JavaScript with single source folder and metaInfo option"]},{"title":"Using Gradle","details":["Plugin and Versions","Targeting the JVM","Targeting JavaScript","Targeting Android","Android Studio","Configuring Dependencies","Annotation processing","Incremental compilation","Compiler Options"]},{"title":"Kotlin and OSGi","details":["Maven","Gradle"]}]